#!/usr/bin/env python3
"""
Dyngo is multi-network dyndns client
It scans addresses on all network interfaces and when some of them
belong to networks listed in the configuration, sends request to
appropriate dyndns severs
"""
import ipaddress
import subprocess
import sys
import getopt
import dbm
from configparser import ConfigParser
import urllib.request
import urllib.parse
import ssl
import logging
import os.path
import time


class DyndnsNetwork(object):
    """
    This class represents dynamic DNS server and network.
    It has attributes hostname network server user and password
    """
    def __init__(self, config_section):
        self.hostname = config_section['hostname']
        self.network = ipaddress.ip_network(config_section['network'])
        self.server = config_section['server']
        if 'user' in config_section:
            self.user = config_section["user"]
            self.password = config_section["password"]

    def contains(self, address):
        """
        Checks if given address belongs to this network
        """
        if self.network.prefixlen == 0 and address.is_private:
            return False
        if self.network.version != address.version:
            return False
        return address in self.network

    def nsupdate(self, address):
        """
        Sends a get query to specified server.
        Raises HTTPError if something goes wrong
        """
        # Construct opener
        logging.debug("Going to send message to %s", self.server)
        handlers = []
        if hasattr(self, 'user'):
            password_mgr = urllib.request.HTTPPasswordMgrWithDefaultRealm()
            password_mgr.add_password(None, self.server, self.user,
                                      self.password)
            handler = urllib.request.HTTPBasicAuthHandler(password_mgr)
            handlers.append(handler)
        if ssl_context is not None:
            handlers.append(urllib.request.HTTPSHandler(context=ssl_context))
        opener = urllib.request.build_opener(*handlers)
        url = '%s?%s' % (self.server,
                         urllib.parse.urlencode({'hostname': self.hostname,
                                                 'myip': str(address)}
                                               ))
        req = urllib.request.Request(url)
        req.add_header('User-Agent', 'Dyngo/1.0')
        with opener.open(req) as resp:
            logging.debug("Server replied: %s", resp.read().decode("utf-8"))
def get_current_addresses():
    """
    Retrieves list of addresses (except link local)
    assigned to this machine using ip command
    and converts them inti IPv4Address or IPv6Address objects.
    """
    result = []
    logging.debug("Acquire current IPs")
    for line in subprocess.run(['ip', '-o', 'addr', 'show'],
                               check=True,
                               stdout=subprocess.PIPE
                              ).stdout.decode('utf-8').split("\n"):
        if not len(line):
            continue
        address = ipaddress.ip_address(line.split()[3].split('/')[0])
        if address.is_loopback or address.is_link_local:
            continue
        result.append(address)
    logging.debug("Got following addresses: %s", repr(result))
    return result

def check_for_update():
    """
    This function is called periodically from main loop and
    performs actual work - comparing list of IP addresses
    with configured dyndns networks.
    """
    addrlist = get_current_addresses()
    for name, net in networks.items():
        found = False
        for addr in addrlist:
            if net.contains(addr):
                found = True
                if name in database:
                    old_addr = ipaddress.ip_address(database[name].decode("utf-8"))
                    if old_addr == addr:
                        # Nothing changed go, to next net
                        logging.debug("Address for net %s not changed", name)
                        break
                # address changed
                try:
                    logging.info("Doing update for net %s with address %s",
                                 name, str(addr))
                    net.nsupdate(addr)
                    database[name] = str(addr)
                except urllib.error.HTTPError as ex:
                    logging.exception("Http error doing nsupdate code %s",
                                      ex.code)
                break
        if not found:
            logging.info("Address for net %s no more found", name)
            if name in database:
                del database[name]


config = ConfigParser()
config['dyngo'] = {'interval': '60', 'database': '/var/lib/dyngo/dyngo.db',
                   'ca': '/etc/ssl/certs', 'loglevel': 'WARNING'}
options = dict(getopt.getopt(sys.argv, "f:")[0])
if '-f' not in options:
    options["-f"] = "/etc/dyngo.conf"
if len(config.read(options["-f"])) != 1:
    print("Cannot read config %s" % options["-f"], file=sys.stderr)
    sys.exit(1)
conf = config['dyngo']
if conf['loglevel'].isdigit():
    level = int(conf['loglevel'])
else:
    try:
        logging.NOTICE = 25
        level = getattr(logging, conf['loglevel'].upper())
    except AttributeError:
        print("Invalid logleevel '%s'" % conf('loglevel'))
        sys.exit(1)

logging.basicConfig(format="%(asctime)s %(message)s",
                    level=level, stream=sys.stderr)
interval = int(conf['interval'])
database = dbm.open(conf['database'], "c")
ssl_context = None
if 'ca' in conf and len(conf['ca']):
    path = conf['ca']
    if os.path.isdir(path):
        ssl_context = ssl.create_default_context(capath=path)
    else:
        ssl_context = ssl.create_default_context(cafile=path)
# Convert all other config sections to DyndnsNetwork objects
networks = {}
for sect in config.sections():
    if sect == 'dyngo' or sect == 'DEFAULT':
        continue
    logging.debug("Processing network %s", sect)
    networks[sect] = DyndnsNetwork(config[sect])
# Remove stale items from persistent database, which are no more
# mentioned in the config file
for i in set([x.decode("utf-8")
              for x in database.keys()]) - set(networks.keys()):
    logging.info("Removing from persistent state network %s" +
                 "which is no more in config", i)
    del database[i]

while True:
    check_for_update()
    time.sleep(interval)
